<?php
/**
 * The project of FishSaying is a SNS platform which is
 * based on voice sharing for each other with journey.
 *
 * The RESTful style API is used to communicate with each client-side.
 *
 * PHP 5
 *
 * FishSaying(tm) : FishSaying (http://www.fishsaying.com)
 * Copyright (c) fishsaying.com. (http://fishsaying.com)
 *
 * Licensed under The MIT License
 * For full copyright and license information, please see the LICENSE.txt
 * Redistributions of files must retain the above copyright notice.
 *
 * @copyright     Copyright (c) fishsaying.com. (http://www.fishsaying.com)
 * @link          http://fishsaying.com FishSaying(tm) Project
 * @since         FishSaying(tm) v 0.0.1
 * @license       MIT License (http://www.opensource.org/licenses/mit-license.php)
 */
APP::uses('MongoToken', 'Utility');
/**
 * @package		app.Model
 */
class Voice extends AppModel {
	
	public $primaryKey = '_id';
	
	public $name = 'Voice';
	
/**
 * Whether $statusChange is false, means status dosen't be changed.
 * 
 * @var string|boolean
 */
	private $statusChange = false;
	
/**
 * a snapshot of voice
 * 
 * @var array
 */
	private $voice = array();
	
/**
 * Unit: meter
 * 
 * @var int
 */
	const DISTANCE_MULTIPLIER = 6378137;
	
/**
 * Waiting for check by admin
 * 
 * @var int
 */
	const STATUS_PENDING = 0;
/**
 * Checked and passed by admin
 * 
 * @var int
 */
	const STATUS_APPROVED = 1;
/**
 * Checked but didn't pass
 * 
 * @var int
 */
	const STATUS_INVALID = 2;
/**
 * Voice froze, can not be played/bought/listed
 * 
 * @var int
 */
    const STATUS_UNAVAILABLE = 3;
    
    const MAX_LENGTH = 300;             // 5 mins...
    const MAX_SCORE = 5.0;              // It's float number
    const MIN_LENGTH_FOR_FREE = 30;     // 30 secs...
    
    const DEFAULT_OFFSET_Y = 0.25;      
    
/**
 * It's mark that voice status transfer
 *  
 * @var string
 */
    const FROM_APPROVED_TO_UNAVAILABLE = 'from_approved_to_unavailable';
    const FROM_APPROVED_TO_INVALID = 'from_approved_to_invalid';
    const FROM_UNAVAILABLE_TO_APPROVED = 'from_unavailable_to_approved';
    const FROM_INVALID_TO_APPROVED = 'from_invalid_to_approved';
    const FROM_PENDING_TO_APPROVED = 'from_pending_to_approved';
    const FROM_PENDING_TO_INVALID = 'from_pending_to_invalid';
    const FROM_INVALID_TO_PENDING = 'from_invalid_to_pending';
	
	public $mongoSchema = array(
	    /**
	     * Unique, only six characters, generated by mongoId
	     */
	    'short_id' => array('type' => 'string'),
		'user_id' => array('type'=>'string'),
		'title' => array('type'=>'string'),
	    /**
	     * It's file key got from QiNiu.com which really hold file itself.
	     * 
	     * It includes:
	     * 1. the path of source.
	     * 2. the path of scaled 80 * 80
	     * 3. the path of scaled 160 * 160
	     * 4. the path of scaled 640 * 640
	     */
		'cover' => array(
		    'source' => array('type'=>'string'),
		    'x80' => array('type'=>'string'),
		    'x160' => array('type'=>'string'),
		    'x640' => array('type'=>'string'),
		),
		/**
		 * It's seconds how long voice can play.
		 */
		'length' => array('type'=>'integer'),
		/**
		 * Description for voice
		 */
		'description' => array('type'=>'string'),    
		/**
		 * It's file key got from QiNiu.com which really hold file itself.
		 */
		'voice' => array('type'=>'string'),
		/**
		 * The current status of voice
		 */
		'status' => array('type'=>'integer'),
		/**
		 * The comment is written by admin when voice status changed to STATUS_INVALID or STATUS_UNAVAILABLE
		 */
		'comment' => array('type'=>'string'),
		/**
		 * Whether voice is free or not
		 */
		'isfree' => array('type'=>'boolean'), 
		'location' => array(
		    'lat' => array('type' => 'float'),
		    'lng' => array('type' => 'float'),
		),
		/**
		 * The max item is 5 for each voice
		 * Using multi-keys index in mongo
		 * The raw data is string that contains multi tags which is seperated by comma.
		 */
		'tags' => array(),
	    /**
	     * The detail address of voice
	     */
	    'address' => array('type' => 'string'),
	    /**
	     * The components of detail address for voice
	     */
	    'address_components' => array('type' => 'string'),
	    'language' => array('type' => 'string'),    // which is language of voice?
	    /**
	     * The total of times that voice is bought.
	     */
	    'checkout_total' => array('type' => 'integer'),
	    /**
	     * The total of times voice is played
	     */
	    'play_total' => array('type' => 'integer'),
	    'earn_total' => array('type' => 'integer'),  // Total of earn
	    'score'      => array('type' => 'float'),    // avarage score (0-5)
	    /**
	     * How many comments have been submitted on?
	     */
        'comment_total'  => array('type' => 'integer'),
        'cover_offset_y' => array('type' => 'double'),
        'deleted'   => array('type' => 'integer'),   // `1`: deleted already, `0`: not yet
        'packages'  => array(), // Package list
        'themes'    => array(), // Theme list
        'recommend' => array('type' => 'integer'),   // Recommend of editor, 1: recommend it, 0: not yet
        'verified_author' => array('type' => 'integer'),
	    /**
	     * Whether voice was created from web, the value is `contrib`, 
	     * otherwise it's empty or not exist.
	     */
        'created_from' => array('type' => 'string'),
		'created'   => array('type' => 'datetime'),     
		'approved'  => array('type' => 'datetime'),
		'status_modified' => array('type' => 'datetime'),
		'modified'  => array('type' => 'datetime')
	);
	
	public function __construct($id = false, $table = null, $ds = null) {
		parent::__construct($id, $table, $ds);
		
		$this->validate = array(
            'user_id' => array(
                'require' => array(
                    'rule' => array('isMongoId'),
                    'required' => 'create',
                    'allowEmpty' => false,
                    'message' => __('The user id must supply') 
                ),
                'verified' => 'chkUserIsVerified',
            ),
            'title' => array(
                'require' => array(
                    'rule' => 'notEmpty',
                    'required' => 'create',
                    'allowEmpty' => false,
                    'message' => __('The title must supply') 
                ) 
            ),
            'description' => array(
                'require' => array(
                    'rule' => 'notEmpty',
                    'allowEmpty' => false,
                    'message' => __('The description must supply') 
                ) 
            ),
            'tags' => array(
                'require' => array(
                    'rule' => array('chkTags'),
                    'allowEmpty' => true,
                    'message' => __('Invalid tags') 
                ) 
            ),
            'cover' => array(
                'require' => array(
                    'rule' => 'chkCover',
                    'required' => 'create',
                    'message' => __('The cover of voice has to upload') 
                ) 
            ),
            'length' => array(
                'require' => array(
                    'rule' => array('chkLength'),
                    'required' => 'create',
                    'allowEmpty' => false,
                    'message' => __('This length must supply') 
                )
            ),
            'voice' => array(
                'require' => array(
                    'rule' => 'notEmpty',
                    'required' => 'create',
                    'allowEmpty' => false,
                    'message' => __('The file of voice must be upload') 
                ) 
            ),
            'status' => array(
                'require' => array(
            		'rule' => array('chkStatus'),
                    'required' => 'create',
                    'allowEmpty' => false,
            		'message' => __('The status must supply')
                )
            ),
		    /**
		     * The rule of `isfree` should be after by `length`
		     */
            'isfree' => array(
                'require' => array(
                    'rule' => array('chkIsfree'),
                    'required' => 'create',
                    'allowEmpty' => false,
                    'message' => __('The isfree must supply') 
                ) 
            ),
		    /*
		     * latitude should first element in location
		     */
            'latitude' => array(
                'require' => array(
                    'rule' => array('chkLatitude'),
                    'required' => 'create',
                    'message' => __('Invalid latitude') 
                ) 
            ),
		    'longitude' => array(
	    		'require' => array(
    				'rule' => array('chkLongitude'),
    				'required' => 'create',
    				'message' => __('Invalid longitude')
	    		)
		    ),
            'location' => array(
                'require' => array(
                    'rule' => array('chkLocation'),
                    'required' => 'create',
                    'message' => __('Invalid location') 
                ) 
            ),
            'address' => array(
                'require' => array(
                    'rule' => 'notEmpty',
                    'required' => 'create',
                    'allowEmpty' => false,
                    'message' => __('Invalid address') 
                ) 
            ),
            'address_components' => array(
                'require' => array(
                    'rule' => array('chkAddressComponents'),
                    'required' => 'create',
                    'allowEmpty' => false,
                    'message' => __('Invalid address components') 
                ) 
            ),
            'language' => array(
                'require' => array(
                    'rule' => array('chkLanguage'),
                    'required' => 'create',
                    'allowEmpty' => false,
                    'message' => __('Invalid language') 
                )
            ),
            'checkout_total' => array(
                'require' => array(
                    'rule' => array('chkCheckoutTotal'),
                    'required' => 'create',
                    'allowEmpty' => false,
                    'message' => __('The checkout_total must supply') 
                ) 
            ),
            'comment_total' => array(
                'require' => array(
                    'rule' => array('chkCommentTotal'),
                    'required' => 'create',
                    'allowEmpty' => false,
                    'message' => __('The comment_total must supply') 
                ) 
            ),
            'earn_total' => array(
                'require' => array(
                    'rule' => array('chkEarnTotal'),
                    'required' => 'create',
                    'allowEmpty' => false,
                    'message' => __('The earn_total must supply') 
                ) 
            ),
            'score' => array(
                'require' => array(
                    'rule' => array('chkScore'),
                    'required' => 'create',
                    'allowEmpty' => false,
                    'message' => __('The score must supply') 
                ) 
            ),
            'comment' => array(
                'require' => array(
                    'rule' => 'notEmpty',
                    'required' => 'create',
                    'allowEmpty' => true,
                    'message' => __('Invalid comment for voice') 
                ) 
            ),
            'cover_offset_y' => array(
                'require' => array(
                    'rule' => array('chkCoverOffsetY'),
                    'required' => 'create',
                    'allowEmpty' => true,
                    'message' => __('Invalid cover_offset_y') 
                ) 
            ),
        );
	}
	
/**
 * (non-PHPdoc)
 * @see Model::implementedEvents()
 */
	public function implementedEvents() {
	    $callbacks = parent::implementedEvents();
	    return array_merge($callbacks, array(
	        'Model.Comment.afterUpdated'       => 'calcScoreByCommentUpdated',
	        'Model.Comment.afterCreated'       => 'calcScoreByCommentCreated',
	        'Model.Comment.afterDeleted'       => 'calcScoreByCommentDeleted', 
	        'Model.Package.afterDeleted'       => 'updatePackage',
	        'Model.Package.afterPush'          => 'updatePackage',             
	        'Model.Package.afterPull'          => 'updatePackage',
	        'Model.Theme.afterDeleted'         => 'updateTheme',
	        'Model.Theme.afterPush'            => 'updateTheme',
	        'Model.Theme.afterPull'            => 'updateTheme',
	        'Model.User.afterUpdate.Verified'  => 'updateVerifiedAuthor'
	    ));
	}
	
/**
 * (non-PHPdoc)
 * @see Model::beforeValidate()
 */
	public function beforeValidate($options = array()) {
	    if(!$this->isMainModel()) return;
	    
	    if(!($id = $this->isUpdate())) {
	        // while saving...
	        /*
	         * Initialize voice data...
	         */
	        $this->data[$this->name]['checkout_total'] = 0;
	        $this->data[$this->name]['score'] = 0;
	        $this->data[$this->name]['comment_total'] = 0;
	        $this->data[$this->name]['earn_total'] = 0;
	        $this->data[$this->name]['play_total'] = rand(3, 10);
	        $this->data[$this->name]['status'] = self::STATUS_PENDING;
	        $this->data[$this->name]['comment'] = '';
	        $this->data[$this->name]['deleted'] = false;
	        
	        // Initial `isfree` according to `length` if `isfree` doesn't exist
	        if(!isset($this->data[$this->name]['isfree'])) {
            	if(isset($this->data[$this->name]['length']) 
            	    && $this->data[$this->name]['length'] > self::MIN_LENGTH_FOR_FREE) {
            		$this->data[$this->name]['isfree'] = 0;
            	} else {
            		$this->data[$this->name]['isfree'] = 1;
            	}
	        }
	        
	        $offset = $this->gets('cover_offset_y', $this->data[$this->name]);
	        if(!is_numeric($offset) && !$offset) {
	            $this->data[$this->name]['cover_offset_y'] = self::DEFAULT_OFFSET_Y;
	        } 
	    } else {
	        // while updating...
	        if(isset($this->data[$this->name]['recommend'])) 
	            $this->data[$this->name]['recommend'] = (int)$this->data[$this->name]['recommend'];
	        
	        $this->voice = $this->findById($id);
	        
	    }
	}
	
/**
 * (non-PHPdoc)
 * @see Model::afterSave()
 */
	public function afterSave($created, $options = array()) {
	    // To prevent be invoked by other models...
	    if(!$this->isMainModel()) return;
	    
	    
	    if($created) {
	        // Generate short id for voice
	        $token = new MongoToken();
	        $this->data[$this->name]['short_id'] = $token->generate($this->id);
	        $this->updateAll(
	                array('$set' => array('short_id' => $this->data[$this->name]['short_id'])), 
	                array('_id' => new MongoId($this->id)));
	        $this->updateStatusModified($this->id);
	        $this->data[$this->name]['status_modified'] = $this->data[$this->name]['modified'];
	        $this->getEventManager()->dispatch(new CakeEvent('Model.Voice.afterCreated', $this));
	    } else {
	        // update status modified if status changed...
	        if($this->statusChange) $this->updateStatusModified($this->id);   
	        $this->read(null, $this->id);
	        
            switch($this->statusChange) {	     
                case self::FROM_APPROVED_TO_UNAVAILABLE:
        	        $this->getEventManager()->dispatch(
        	           new CakeEvent('Model.Voice.afterUpdated.status.from.approved.to.unavailable', $this));    
        	        CakeResque::enqueue('notification', 'NotificationShell',
        	            array('unavailable', $this->data[$this->name])
        	        );
        	        break;
                case self::FROM_APPROVED_TO_INVALID:       
        	        $this->getEventManager()->dispatch(
        	                new CakeEvent('Model.Voice.afterUpdated.status.from.approved.to.invalid', $this));
        	        CakeResque::enqueue('notification', 'NotificationShell',
        	            array('invalid', $this->data[$this->name])
        	        );
        	        break;
                case self::FROM_UNAVAILABLE_TO_APPROVED: 
        	        $this->getEventManager()->dispatch(
        	           new CakeEvent('Model.Voice.afterUpdated.status.from.unavailable.to.approved', $this));
        	        CakeResque::enqueue('notification', 'NotificationShell',
        	            array('approvedAgain', $this->data[$this->name])
        	        );
        	        break;
                case self::FROM_PENDING_TO_APPROVED:    
                    if($this->voice && 
                        (!isset($this->voice[$this->name]['approved']) || empty($this->voice[$this->name]['approved']))) {
                    	 $this->updateApproved($this->id);
                    	 $now = new MongoDate();
                    	 $this->data[$this->name]['approved']['sec'] = $now->sec;
                    	 $this->data[$this->name]['approved']['usec'] = $now->usec;
                    }  
        	        $this->getEventManager()->dispatch(
        	           new CakeEvent('Model.Voice.afterUpdated.status.from.pending.to.approved', $this));
        	        CakeResque::enqueue('notification', 'NotificationShell',
        	            array('approved', $this->data[$this->name])
        	        );
        	        CakeResque::enqueue('notification', 'NotificationShell',
        	            array('newPost',  $this->data[$this->name])
        	        );
        	        break;
                case self::FROM_PENDING_TO_INVALID:
        	        $this->getEventManager()->dispatch(
        	           new CakeEvent('Model.Voice.afterUpdated.status.from.pending.to.invalid', $this));
        	        CakeResque::enqueue('notification', 'NotificationShell',
        	            array('invalid', $this->data[$this->name])
        	        );
        	        break;
            }
            
            $this->getEventManager()->dispatch(new CakeEvent('Model.Voice.afterUpdated', $this));
	    }
	}
		
/**
 * (non-PHPdoc)
 * @see Model::afterDelete()
 */
	public function afterDelete() {
	    parent::afterDelete();
	    // Whether deleted voice's status is approved...
	    if(isset($this->data[$this->name]['status'])
	        && $this->data[$this->name]['status'] == self::STATUS_APPROVED) {
	    	$this->getEventManager()->dispatch(new CakeEvent('Model.Voice.afterDeleted.approve', $this));
	    }
	    $this->getEventManager()->dispatch(new CakeEvent('Model.Voice.afterDeleted', $this));
	}
	
	public function updateTheme(CakeEvent $event) {
	    $model  = $event->subject();
	    $data   = $model->data[$model->name];
	    // For add new voices into themes...
	    $voices = isset($data['add']) ? $data['add'] : array();
	    foreach($voices as $voice) {
	        $this->updateAll(array(
	            '$push' => array('themes' => $model->id)
	        ), array(
	            '_id' => new MongoId($voice)
	        ));
	    }
	    
	    // For remove old voices from package...
	    $voices = isset($data['del']) ? $data['del'] : array();
	    foreach($voices as $voice) {
	    	$this->updateAll(array(
	    		'$pull' => array('themes' => $model->id)
	    	), array(
	    		'_id' => new MongoId($voice)
	    	));
	    }
	}
	
	public function updatePackage(CakeEvent $event) {
	    $model  = $event->subject();
	    $data   = $model->data[$model->name];
	    $pkgId  = $model->id;
	    // For add new voices into package...
	    $voices = isset($data['add']) ? $data['add'] : array();
	    foreach($voices as $voice) {
	        $this->updateAll(array(
	            '$push' => array('packages' => $pkgId)
	        ), array(
	            '_id' => new MongoId($voice)
	        ));
	    }
	    
	    // For remove old voices from package...
	    $voices = isset($data['del']) ? $data['del'] : array();
	    foreach($voices as $voice) {
	    	$this->updateAll(array(
	    		'$pull' => array('packages' => $pkgId)
	    	), array(
	    		'_id' => new MongoId($voice)
	    	));
	    }
	}
	
	public function updateVerifiedAuthor(CakeEvent $event) {
	    $model = $event->subject();
	    $data  = $model->data[$model->name];
	    $this->updateAll(array(
	    	'verified_author' => (int)$data['is_verified']
	    ), array(
	    	'user_id' => $model->id
	    ));
	    
	    $voices = $this->find('all', array(
	        'conditions' => array(
	            'user_id' => $model->id
	        )
	    ));
	    $this->getEventManager()->attach(new \Model\Index\Voice());
	    foreach($voices as $voice) {
	        $this->set($voice[$this->name]);
	        $this->getEventManager()->dispatch(new CakeEvent('Model.Voice.afterUpdated', $this));
	    }
	}
	
	public function updateStatusModified($voiceId) {
	    return $this->updateAll(array(
	        'status_modified' => new MongoDate(
	                $this->data[$this->name]['modified']->sec, 
	                $this->data[$this->name]['modified']->usec)
	    ), array(
	        '_id' => new MongoId($voiceId)
	    ));
	}
	
	public function updateApproved($voiceId) {
	    return $this->updateAll(array(
	        'approved' => new MongoDate(
	                $this->data[$this->name]['modified']->sec, 
	                $this->data[$this->name]['modified']->usec)
	    ), array(
	        '_id' => new MongoId($voiceId)
	    ));
	}
	
/**
 * Update average score when new comment is created. 
 * 
 * @param CakeEvent $event
 */
	public function calcScoreByCommentCreated(CakeEvent $event) {
	    $model = $event->subject();
        $comment = $model->data[$model->name];
        $voice = $this->findById($comment['voice_id'])[$this->name];
        
        $average = (float) $voice['score'];
        $total = $average * ($voice['comment_total']) + $comment['score'];
        $count = ($voice['comment_total'] + 1);
        $average = $total / $count;
            
	    $result = $this->updateAll(array(
	        '$inc' => array('comment_total' => 1), 
	        '$set' => array('score' => $average)), 
	        array('_id' => new MongoId($comment['voice_id'])
	    ));
	    
	    if($result) {
	        $voice['comment_total'] += 1;
	        $voice['score'] = $average;
	        CakeResque::enqueue('indexing', 'VoiceIndexShell', array('add', $voice));
	        return array('comment_total' => $count, 'score' => $average);
	    }
	}
	
/**
 * Update average score when comment is updated. 
 * 
 * @param CakeEvent $event
 */
	public function calcScoreByCommentUpdated(CakeEvent $event) {
        $comment = $event->subject()->data;
        $score = $comment['Comment']['score'];
        $prev = $comment['Comment']['prev_score'];
        $voice = $this->findById($comment['Comment']['voice_id']);
        
        $average = (float) $voice[$this->name]['score'];
        $total = $average * $voice[$this->name]['comment_total'] - $prev + $score;
        if($voice[$this->name]['comment_total'] > 0) {
            $average = $total / $voice[$this->name]['comment_total'];
        } else {
            $average = 0;
        }
            
	    $result = $this->updateAll(
	        array('$set' => array('score' => $average)), 
	        array('_id' => new MongoId($comment['Comment']['voice_id'])
	    ));
	    
	    if($result) {
	        $voice[$this->name]['score'] = $average;
	        CakeResque::enqueue('indexing', 'VoiceIndexShell', array('add', $voice[$this->name]));
	        return array('comment_total' => $voice[$this->name]['comment_total'], 'score' => $average);
	    }
	}
	
/**
 * Update average score when comment is deleted. 
 * 
 * @param CakeEvent $event
 */
	public function calcScoreByCommentDeleted(CakeEvent $event) {
        $comment = $event->subject()->data;
        $score = $comment['Comment']['score'];
        $voice = $this->findById($comment['Comment']['voice_id']);
        
        $average = (float) $voice[$this->name]['score'];
        $total = $average * ($voice[$this->name]['comment_total']) - $score;
        $count = $voice[$this->name]['comment_total'] - 1;
        if($count > 0) {
            $average = $total / $count;
        } else {
            $average = 0;
        }
            
	    $result = $this->updateAll(array(
            '$inc' => array('comment_total' => -1), 
            '$set' => array('score' => $average)), 
            array('_id' => new MongoId($comment['Comment']['voice_id'])
	    ));
	    
	    if($result) {
	        $voice[$this->name]['comment_total'] -= 1;
	        $voice[$this->name]['score'] = $average;
	        CakeResque::enqueue('indexing', 'VoiceIndexShell', array('add', $voice[$this->name]));
	        return array('comment_total' => $count, 'score' => $average);
	    }
	}
	
/**
 * Update voice after comment is posted. 
 * 
 * If $step is minus number, It's a descrease action.
 * 
 * @param string $voiceId
 * @param number $score new 
 * @param number $step It would descrease number that $step is.
 */
	public function updateByComment($voiceId, $score, $step) {
	    $maxScore = 5;
	    
        $voice = $this->find('first', array(
            'fields' => array(
                'score',
                'comment_total' 
            ),
            'conditions' => array(
                '_id' => new MongoId($voiceId) 
            ) 
        ));
        
        if($voice) {
            if($step > 0) {
        	    $average = (float) $voice[$this->name]['score'];
        	    $total = $average * ($voice[$this->name]['comment_total']) + $score;
        	    $count = ($voice[$this->name]['comment_total'] + 1);
        	    $average = $total / $count;
            } elseif($step < 0) {
                $average = (float) $voice[$this->name]['score'];
                $total = $average * ($voice[$this->name]['comment_total']) - $score;
                $count = $voice[$this->name]['comment_total'] - 1;
                if($count > 0) {
                    $average = $total / $count;
                } else {
                    $average = 0;
                }
            } else { // $step == 0
                $average = (float) $voice[$this->name]['score'];
//                 $total = $average * $voice[$this->name]['comment_total'] - ($maxScore - $score);
                $total = $average * $voice[$this->name]['comment_total'] + $score;
                $count = $voice[$this->name]['comment_total'];
                if($count > 0) {
                    $average = $total / $count;
                } else {
                    $average = 0;
                }
            }
            
    	    $result = $this->updateAll(
    	        array('$inc' => array('comment_total' => $step),'$set' => array('score' => $average)), 
    	        array('_id' => new MongoId($voiceId)));
    	    
    	    if($result) {
    	        $voice[$this->name]['comment_total'] += $step;
    	        $voice[$this->name]['score'] = $average;
    	        CakeResque::enqueue('indexing', 'VoiceIndexShell', array('add', $voice[$this->name]));
    	        return array('comment_total' => $count, 'score' => $average);
    	    }
        }
        
        return false;
	}
	
/**
 * Update voice status when voice is purchased.
 * 
 * @param string $voiceId
 * @return boolean
 */
	public function updateCheckoutTotal($voiceId) {
	    $result = $this->updateAll(
	        array('$inc' => array('checkout_total' => 1)),
	        array('_id' => new MongoId($voiceId)));
	    
	    $voice = $this->findById($voiceId);
	    CakeResque::enqueue('indexing', 'VoiceIndexShell', array('add', $voice[$this->name]));
	    
	    return $result;
	}
	
/**
 * Update voice total when voice is played.
 * 
 * @param string $voiceId
 * @return boolean
 */
	public function updatePlayTotal($voiceFileName, $count = 1) {
	    if($count <= 0) return false;
	    $result = $this->updateAll(
	        array('$inc' => array('play_total' => $count)),
	        array('voice' => $voiceFileName));
	    
	    $voice = $this->findByVoice($voiceFileName);
	    CakeResque::enqueue('indexing', 'VoiceIndexShell', array('add', $voice[$this->name]));
	    return $result;
	}
	
/**
 * Update total number of `earn_total`
 * Just count `earn_total` by non-free.
 *  
 * @param string $voiceId
 * @param int $length
 * @return boolean
 */
	public function updateEarnTotal($voiceId, $length) {
	    $result = $this->updateAll(array(
	        '$inc' => array('earn_total' => $length),
	    ), array(
	        '_id' => new MongoId($voiceId)
	    ));
	    
	    $voice = $this->findById($voiceId);
	    CakeResque::enqueue('indexing', 'VoiceIndexShell', array('add', $voice[$this->name]));
	     
	    return $result;
	}
	
/**
 * Count voice length by user
 * 
 * @param string $userId
 * @param string $status
 * @return number
 */
	public function getLengthCount($userId, $status = false) {
	    $conditions = array(
	        'user_id' => $userId
	    );
	    if($status !== false) {
	        $conditions['status'] = $status;
	    }
	    $voices = $this->find('all', array(
	        'fields' => array('length'),
	        'conditions' => $conditions
	    ));
	    $total = 0;
	    foreach($voices as $voice) {
	        $total += $voice[$this->name]['length'];
	    }
	    return $total;
	}
	
/**
 * Count voice number of user
 * 
 * @param string $userId
 * @return int
 */
	public function count($userId, $status = '') {
	    $conditions = array(
	        'user_id' => $userId
	    );
	    if($status) {
	        $conditions['status'] = $status;
	    }
	    return $this->find('count', array(
	        'conditions' => $conditions
	    ));
	}
	
/**
 * Check whether there is uploaded file as cover image or not.
 * 
 * @param array $check
 * @return boolean
 */
	public function chkTags($check) {
        $items = explode(',', $this->getCheck('tags', $check));
        foreach($items as &$item) $item = trim($item);
        $this->data[$this->name]['tags'] = $items;
        return true;
	}
	
/**
 * Check whether there is uploaded file as cover image or not.
 * 
 * @param array $check
 * @return boolean
 */
	public function chkCover($check) {
	    $field = '';
	    if(isset($check['cover'])) {
	        $field = $check['cover'];
	    } else {
	        $field = $check;
	    }
	    if($field) {
	    	$this->data[$this->name]['cover'] = array();
	    	$this->data[$this->name]['cover']['source'] = $field;
	    	$this->data[$this->name]['cover']['x80']    = $field;
	    	$this->data[$this->name]['cover']['x160']   = $field;
	    	$this->data[$this->name]['cover']['x640']   = $field;
	    	return true;
	    }
	    return false;
	}
	
/**
 * Check whether the location that is consisted with latitude 
 * and longitude is valid or not.
 * 
 * @param array $check
 * @return boolean
 */
	public function chkLatitude($check) {
	    $field = '';
	    if(isset($check['latitude'])) {
	        $field = $check['latitude'];
	    } else {
	        $field = $check;   
	    }
        if($field) {
            $latitude = (double) $field;
            if(($latitude >= -90) && ($latitude <= 90)) {
                $this->data[$this->name]['location']['lat'] = $latitude;
                unset($this->data[$this->name]['latitude']);
                return true;
            }
        }
        return false;
	}
	
/**
 * Check whether the location that is consisted with latitude 
 * and longitude is valid or not.
 * 
 * @param array $check
 * @return boolean
 */
	public function chkLongitude($check) {
	    $field = '';
	    if(isset($check['longitude'])) {
	        $field = $check['longitude'];
	    } else {
	        $field = $check;   
	    }
        if($field) {
            $longitude = (double) $field;
            if(($longitude >= -180) && ($longitude <= 180)) {
                $this->data[$this->name]['location']['lng'] = $longitude;
                unset($this->data[$this->name]['longitude']);
                return true;
            }
        }
        return false;
	}
	
/**
 * Check whether the location that is consisted with latitude 
 * and longitude is valid or not.
 * 
 * @param array $check
 * @return boolean
 */
	public function chkLocation($check) {
	    if(isset($check['location'])) {
	        if(isset($check['location']['lat']) && isset($check['location']['lng'])) {
	            if(!empty($check['location']['lat']) && !empty($check['location']['lng'])) {
	                return true;
	            }
	        }
	    }
        return false;
	}

/**
 * Check whether voice status is valid or not.
 *
 * @param array|int $check            
 * @return boolean
 */
    public function chkStatus($check) {
        if(isset($check['status'])) {
            $status = (int)$check['status'];
        } else {
            $status = $check;
        }
        /*
         * Initial all status of voice
         */
        $valid = array(
            self::STATUS_APPROVED,
            self::STATUS_INVALID,
            self::STATUS_PENDING,
            self::STATUS_UNAVAILABLE 
        );
        if(in_array($status, $valid)) {
            $this->data[$this->name]['status'] = $status;
            
            // Whether it's editing...
//             $voiceId = false;
//             if(isset($this->data[$this->name]['_id'])) {
//                 $voiceId = $this->data[$this->name]['_id'];
//             }
//             if(!empty($this->id)) {
//                 $voiceId = $this->id;
//             }
            $voiceId = $this->isUpdate();
            // Get status transfer presentation
            if($voiceId) {
//                 $original = $this->findById($voiceId);
                $original = $this->voice;
                $originalStatus = false;
                if($original && isset($original[$this->name]['status'])) {
                    $originalStatus = (int)$original[$this->name]['status'];
                    // Whether status is changing...
                    if($originalStatus != $status) {
                        if($originalStatus == self::STATUS_APPROVED && $status == self::STATUS_UNAVAILABLE) {
                            $this->statusChange = self::FROM_APPROVED_TO_UNAVAILABLE;
                        }
                        if($originalStatus == self::STATUS_PENDING && $status == self::STATUS_APPROVED) {
                            $this->statusChange = self::FROM_PENDING_TO_APPROVED;
                        }
                        if($originalStatus == self::STATUS_INVALID && $status == self::STATUS_APPROVED) {
                            $this->statusChange = self::FROM_INVALID_TO_APPROVED;
                        }
                        if($originalStatus == self::STATUS_UNAVAILABLE && $status == self::STATUS_APPROVED) {
                            $this->statusChange = self::FROM_UNAVAILABLE_TO_APPROVED;
                        }
                        if($originalStatus == self::STATUS_PENDING && $status == self::STATUS_INVALID) {
                            $this->statusChange = self::FROM_PENDING_TO_INVALID;
                        }
                        if($originalStatus == self::STATUS_APPROVED && $status == self::STATUS_INVALID) {
                            $this->statusChange = self::FROM_APPROVED_TO_INVALID;
                        }
                        if($originalStatus == self::STATUS_INVALID && $status == self::STATUS_PENDING) {
                            $this->statusChange = self::FROM_INVALID_TO_PENDING;
                        }
                    } else {
                        // Whether voice status isn't changing... 
                        $this->statusChange = false;
                    }
                }
            } else {
                // Whether it's creating new one...
                $this->statusChange = false;
            }
            return true;
        }
        return false;
    }
    
/**
 * Reformat value of `isfree`.
 * 
 * @param array|boolean|int $check
 * @return boolean
 */
    public function chkIsfree($check) {
        $isfree = NULL;    // default it's not free...
        if(isset($check['isfree'])) {
        	$isfree = $check['isfree'];
        } else {
        	$isfree = $check;
        }
        $this->data[$this->name]['isfree'] = (int)(bool) $isfree;
        return true;
    }
    
/**
 * Reformat value of `checkout_total`.
 * 
 * @param array|boolean|int $check
 * @return boolean
 */
    public function chkCheckoutTotal($check) {
        if(isset($check['checkout_total'])) {
        	$field = $check['checkout_total'];
        } else {
        	$field = $check;
        }
        $this->data[$this->name]['checkout_total'] = (int) $field;
        return true;
    }
    
/**
 * Reformat value of `comment_total`.
 * 
 * @param array|boolean|int $check
 * @return boolean
 */
    public function chkCommentTotal($check) {
        if(isset($check['comment_total'])) {
        	$field = $check['comment_total'];
        } else {
        	$field = $check;
        }
        $this->data[$this->name]['comment_total'] = (int) $field;
        return true;
    }
    
/**
 * Check whether the value of `length` is valid or not.
 * 
 * @param array|boolean|int $check
 * @return boolean
 */
    public function chkLength($check) {
        if(isset($check['length'])) {
        	$length = (int) $check['length'];
        } else {
        	$length = (int) $check;
        }
        if($length <= 0 || $length > self::MAX_LENGTH) {
            return false;
        }
        $this->data[$this->name]['length'] = $length;
        
        // Whether no found `isfree` field...
        if($this->data[$this->name]['length'] > self::MIN_LENGTH_FOR_FREE) {
        	// It should check `length` to decide whether voice is free or not...
        	$this->data[$this->name]['isfree'] = 0;
        } else {
        	$this->data[$this->name]['isfree'] = 1;
        }
        return true;
    }
    
/**
 * Reformat value of `earn_total`.
 * 
 * @param array|boolean|int $check
 * @return boolean
 */
    public function chkEarnTotal($check) {
        if(isset($check['earn_total'])) {
        	$field = (int) $check['earn_total'];
        } else {
        	$field = (int) $check;
        }
        $this->data[$this->name]['earn_total'] = $field;
        return true;
    }
    
/**
 * Reformat value of `score`.
 * 
 * @param array|boolean|int $check
 * @return boolean
 */
    public function chkScore($check) {
        if(isset($check['score'])) {
        	$field = (float) $check['score'];
        } else {
        	$field = (float) $check;
        }
        if($field > self::MAX_SCORE) {
            return false;
        }
        $this->data[$this->name]['score'] = $field;
        return true;
    }
    
/**
 * Reformat value of `language`.
 * 
 * @param array|boolean|int $check
 * @return boolean
 */
    public function chkLanguage($check) {
        if(isset($check['language'])) {
        	$field = $check['language'];
        } else {
        	$field = $check;
        }
        
        if(!$field) {
        	return false;
        }
        
        if(!in_array($field, Configure::read('Locale.Supported'))) {
        	return false;
        }
        
        return true;
    }
    
/**
 * Reformat value of `cover_offset_y`.
 * 
 * @param array|double $check
 * @return boolean
 */
    public function chkCoverOffsetY($check) {
        if(isset($check['cover_offset_y'])) {
        	$field = $check['cover_offset_y'];
        } else {
        	$field = $check;
        }
        
        if(!is_numeric($field)) {
            return false;
        }
        
        $this->data[$this->name]['cover_offset_y'] = round($field, 2);
        return true;
    }
    
/**
 * Reformat value of `address_components`.
 * 
 * @param array $check
 * @return boolean
 */
    public function chkAddressComponents($check) {
        if(isset($check['address_components'])) {
        	$field = $check['address_components'];
        } else {
        	$field = $check;
        }
    	$components = json_decode($field, true);
    	if($components === NULL) {
    		$field = array();
    	} else {
    		$field = $this->cleanupAddressComponents($components);
    	}
        $this->data[$this->name]['address_components'] = $field;
        return true;
    }
    
    public function chkUserIsVerified($check) {
        foreach($check as $key => $val) {
            $model = ClassRegistry::init('User');
            if($model->isVerified($val))
                $this->data[$this->name]['verified_author'] = 1;
        }
        return true;
    }
    
    private function cleanupAddressComponents($components = array()) {
    	$info = array();
    	if($components && is_array($components)) {
    		$len = count($components);
    		for($i = $len; $i > 0; $i--) {
    			$item = $components[$i - 1];
    			if(isset($item['types'][0]) && isset($item['long_name'])) {
    				$info[$item['types'][0]] = $item['long_name'];
    			}
    		}
    	}
    	return $info;
    }
    
/**
 * Whether $statusChange is false, means status dosen't be changed.
 * 
 * @return Ambigous <string, boolean>
 */
    public function getStatusTransferPresentation() {
        return $this->statusChange;
    }
}